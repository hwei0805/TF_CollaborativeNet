.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Simple 3"
.TH Simple 3 "2006-09-12" "perl v5.8.5" "User Contributed Perl Documentation"
.SH "NAME"
Config::Simple \- simple configuration file class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Config::Simple;
.Ve
.PP
.Vb 2
\&  # --- Simple usage. Loads the config. file into a hash:
\&  Config::Simple->import_from('app.ini', \e%Config);
.Ve
.PP
.Vb 2
\&  # --- OO interface:
\&  $cfg = new Config::Simple('app.ini');
.Ve
.PP
.Vb 2
\&  # accessing values:
\&  $user = $cfg->param('User');
.Ve
.PP
.Vb 2
\&  # getting the values as a hash:
\&  %Config = $cfg->vars();
.Ve
.PP
.Vb 2
\&  # updating value with a string
\&  $cfg->param('User', 'sherzodR');
.Ve
.PP
.Vb 2
\&  # updating a value with an array:
\&  $cfg->param('Users', ['sherzodR', 'geek', 'merlyn']);
.Ve
.PP
.Vb 2
\&  # adding a new block to an ini-file:
\&  $cfg->param(-block=>'last-access', -values=>{'time'=>time()});
.Ve
.PP
.Vb 2
\&  # accessing a block of an ini-file;
\&  $mysql = $cfg->param(-block=>'mysql');
.Ve
.PP
.Vb 2
\&  # saving the changes back to file:
\&  $cfg->save();
.Ve
.PP
.Vb 2
\&  # --- tie() interface
\&  tie %Config, "Config::Simple", 'app.ini';
.Ve
.SH "ABSTRACT"
.IX Header "ABSTRACT"
Reading and writing configuration files is one of the most frequent
tasks of any software design. Config::Simple is the library that helps
you with it.
.PP
Config::Simple is a class representing configuration file object. 
It supports several configuration file syntax and tries to identify the 
file syntax automatically. Library supports parsing, updating and creating 
configuration files.
.SH "ABOUT CONFIGURATION FILES"
.IX Header "ABOUT CONFIGURATION FILES"
Keeping configurable variables in your program source code is ugly, really.
And for people without much of a programming experience, configuring
your programs is like performing black magic. Besides, if you need to
access these values from within multiple files, want your programs
to be able to update configuration files or want to provide a friendlier
user interface for your configuration files, you just have to store them in 
an external file. That's where Config::Simple comes into play, making it
very easy to read and write configuration files.
.PP
If you have never used configuration files before, here is a brief
overview of various syntax to choose from. Otherwise you can jump to
\&\*(L"\s-1PROGRAMMING\s0 \s-1STYLE\s0\*(R".
.Sh "\s-1SIMPLE\s0 \s-1CONFIGURATION\s0 \s-1FILE\s0"
.IX Subsection "SIMPLE CONFIGURATION FILE"
Simple syntax is what you need for most of your projects. These
are, as the name asserts, the simplest. File consists of key/value
pairs, delimited by nothing but white space. Keys (variables) should
be strictly alpha-numeric with possible dashes (\-). Values can hold
any arbitrary text. Here is an example of such a configuration file:
.PP
.Vb 2
\&  Alias     /exec
\&  TempFile  /usr/tmp
.Ve
.PP
Comments start with a pound ('#') sign and cannot share the same
line with other configuration data.
.Sh "HTTP-LIKE \s-1SYNTAX\s0"
.IX Subsection "HTTP-LIKE SYNTAX"
This format of separating key/value pairs is used by \s-1HTTP\s0 messages.
Each key/value is separated by semi-colon (:). Keys are alphanumeric
strings with possible '\-'. Values can be any arbitrary text:
.PP
Example:
.PP
.Vb 2
\&  Alias: /exec
\&  TempFile: /usr/tmp
.Ve
.PP
It is \s-1OK\s0 to have spaces around ':'. Comments start with '#' and cannot
share the same line with other configuration data.
.Sh "INI-FILE"
.IX Subsection "INI-FILE"
These configuration files are more native to Win32 systems. Data
is organized in blocks. Each key/value pair is delimited with an
equal (=) sign. Blocks are declared on their own lines enclosed in
\&'[' and ']':
.PP
.Vb 3
\&  [BLOCK1]
\&  KEY1=VALUE1
\&  KEY2=VALUE2
.Ve
.PP
.Vb 3
\&  [BLOCK2]
\&  KEY1=VALUE1
\&  KEY2=VALUE2
.Ve
.PP
Your Winamp 2.x play list is an example of such a configuration file.
.PP
This is the perfect choice if you need to organize your configuration
file into categories:
.PP
.Vb 4
\&  [site]
\&  url="http://www.handalak.com"
\&  title="Web site of a \e"Geek\e""
\&  author=sherzodr
.Ve
.PP
.Vb 4
\&  [mysql]  
\&  dsn="dbi:mysql:db_name;host=handalak.com"
\&  user=sherzodr
\&  password=marley01
.Ve
.Sh "\s-1SIMPLIFIED\s0 INI-FILE"
.IX Subsection "SIMPLIFIED INI-FILE"
These files are pretty much similar to traditional ini\-files, except they don't
have any block declarations. This style is handy if you do not want any categorization
in your configuration file, but still want to use '=' delimited key/value pairs. 
While working with such files, Config::Simple assigns them to a default block, 
called 'default' by default :\-).
.PP
.Vb 1
\&  url = "http://www.handalak.com"
.Ve
.PP
Comments can begin with either pound ('#') or semi-colon (';'). Each comment
should reside on its own line
.SH "PROGRAMMING STYLE"
.IX Header "PROGRAMMING STYLE"
Most of the programs simply need to be able to read settings from a configuration
file and assign them to a hash. If that's all you need, you can simply use
its \fIimport_from()\fR \- class method with the name of the configuration file
and a reference to an existing (possibly empty) hash:
.PP
.Vb 1
\&  Config::Simple->import_from('myconf.cfg', \e%Config);
.Ve
.PP
Now your hash \f(CW%Config\fR holds all the configuration file's key/value pairs.
Keys of a hash are variable names inside your configuration file, and values
are their respective values. If \*(L"myconf.cfg\*(R" was a traditional ini\-file, 
keys of the hash consist of block name and variable delimited with a dot, such
as \*(L"block.var\*(R".
.PP
If that's all you need, you can stop right here. Otherwise, read on. There is
much more Config::Simple offers.
.Sh "\s-1READING\s0 \s-1THE\s0 \s-1CONFIGURATION\s0 \s-1FILE\s0"
.IX Subsection "READING THE CONFIGURATION FILE"
To be able to use more features of the library, you will need to use its object
interface:
.PP
.Vb 1
\&  $cfg = new Config::Simple('app.cfg');
.Ve
.PP
The above line reads and parses the configuration file accordingly.
It tries to guess which syntax is used by passing the file to \fIguess_syntax()\fR method.
Alternatively, you can create an empty object, and only then read the configuration file in:
.PP
.Vb 2
\&  $cfg = new Config::Simple();
\&  $cfg->read('app.cfg');
.Ve
.PP
As in the first example, \fIread()\fR also calls \fIguess_syntax()\fR method on the file.
.PP
If, for any reason, it fails to guess the syntax correctly (which is less likely),
you can try to debug by using its \fIguess_syntax()\fR method. It expects
file handle for a  configuration file and returns the name of a syntax. Return
value is one of \*(L"ini\*(R", \*(L"simple\*(R" or \*(L"http\*(R".
.PP
.Vb 2
\&  open(FH, "app.cfg");
\&  printf("This file uses '%s' syntax\en", $cfg->guess_syntax(\e*FH));
.Ve
.Sh "\s-1ACCESSING\s0 \s-1VALUES\s0"
.IX Subsection "ACCESSING VALUES"
After you read the configuration file in successfully, you can use \fIparam()\fR 
method to access the configuration values. For example:
.PP
.Vb 1
\&  $user = $cfg->param("User");
.Ve
.PP
will return the value of \*(L"User\*(R" from either simple configuration file, or
http-styled configuration as well as simplified ini\-files. To access the
value from a traditional ini\-file, consider the following syntax:
.PP
.Vb 1
\&  $user = $cfg->param("mysql.user");
.Ve
.PP
The above returns the value of \*(L"user\*(R" from within \*(L"[mysql]\*(R" block. Notice the
use of dot \*(L".\*(R" to delimit block and key names.
.PP
Config::Simple also supports \fIvars()\fR method, which, depending on the context
used, returns all the values either as hashref or hash:
.PP
.Vb 2
\&  my %Config = $cfg->vars();
\&  print "Username: $Config{User}";
.Ve
.PP
.Vb 2
\&  # If it was a traditional ini-file:
\&  print "Username: $Config{'mysql.user'}";
.Ve
.PP
If you call \fIvars()\fR in scalar context, you will end up with a reference to a hash:
.PP
.Vb 2
\&  my $Config = $cfg->vars();
\&  print "Username: $Config->{User}";
.Ve
.PP
If you know what you're doing, you can also have an option of importing all the
names from the configuration file into your current name space as global variables.
All the block/key names will be uppercased and will be converted to Perl's valid
variable names; that is, all the dots (block\-key separator) and other '\eW' characters will be 
substituted with underscore '_':
.PP
.Vb 2
\&  $cfg = new Config::Simple('app.cfg');
\&  $cfg->import_names();
.Ve
.PP
.Vb 2
\&  # or, with a single line:
\&  Config::Simple->new('app.cfg')->import_names();
.Ve
.PP
.Vb 1
\&  print STDERR "Debugging mode is on" if $DEBUG_MODE;
.Ve
.PP
In the above example, if there was a variable 'mode' under '[debug]' block,
it will be now accessible via \f(CW$DEBUG_MODE\fR, as opposed to \f(CW$cfg\fR\->param('debug.mode');
.PP
\&\f(CW\*(C`import_names()\*(C'\fR by default imports the values to its caller's name space. 
Optionally, you can specify where to import the values by passing the name of the 
name space as the first argument. It also prevents potential name collisions:
.PP
.Vb 2
\&  Config::Simple->new('app.cfg')->import_names('CFG');
\&  print STDERR "Debugging mode is on" if $CFG::DEBUG_MODE;
.Ve
.PP
If all you want is to import values from a configuration file, the above syntax may still
seem longer than necessary. That's why Config::Simple supports \fIimport_from()\fR \- class method,
which is called with the name of the configuration file. It will call \fIimport_names()\fR for you:
.PP
.Vb 1
\&  Config::Simple->import_from('app.cfg');
.Ve
.PP
The above line imports all the variables into the caller's name space. It's similar to
calling \fIimport_names()\fR on an object. If you pass a string as the second argument,
it will treat it as the alternative name space to import the names into. As we 
already showed in the very first example, you can also pass a reference to an existing
hash as the second argument. In this case, that hash will be modified with the values
of the configuration file.
.PP
.Vb 2
\&  # import into $CFG name space:
\&  Config::Simple->import_from('app.cfg', 'CFG');
.Ve
.PP
.Vb 2
\&  # import into %Config hash:
\&  Config::Simple->import_from('app.cfg', \e%Config);
.Ve
.PP
The above line imports all the values to '\s-1CFG\s0' name space. \fIimport_from()\fR returns
underlying Config::Simple object (which you may not even need anymore):
.PP
.Vb 2
\&  $cfg = Config::Simple->import_from('app.cfg', \emy %Config);
\&  $cfg->write('app.cfg.bak');
.Ve
.Sh "\s-1UPDATING\s0 \s-1THE\s0 \s-1VALUES\s0"
.IX Subsection "UPDATING THE VALUES"
Configuration values, once read into Config::Simple, can be updated from within
your program by using the same \fIparam()\fR method used for accessing them. For example:
.PP
.Vb 1
\&  $cfg->param("User", "sherzodR");
.Ve
.PP
The above line changes the value of \*(L"User\*(R" to \*(L"sherzodR\*(R". Similar syntax is applicable
for ini-files as well:
.PP
.Vb 1
\&  $cfg->param("mysql.user", "sherzodR");
.Ve
.PP
If the key you're trying to update does not exist, it will be created. For example,
to add a new \*(L"[session]\*(R" block to your ini\-file, assuming this block doesn't already
exist:
.PP
.Vb 1
\&  $cfg->param("session.life", "+1M");
.Ve
.PP
You can also delete values calling \fIdelete()\fR method with the name of the variable:
.PP
.Vb 1
\&  $cfg->delete('mysql.user'); # deletes 'user' under [mysql] block
.Ve
.Sh "\s-1SAVING/WRITING\s0 \s-1CONFIGURATION\s0 \s-1FILES\s0"
.IX Subsection "SAVING/WRITING CONFIGURATION FILES"
The above updates to the configuration values are in-memory operations. They
do not reflect in the file itself. To modify the files accordingly, you need to
call either \*(L"\fIwrite()\fR\*(R" or \*(L"\fIsave()\fR\*(R" methods on the object:
.PP
.Vb 1
\&  $cfg->write();
.Ve
.PP
The above line writes the modifications to the configuration file. Alternatively,
you can pass a name to either \fIwrite()\fR or \fIsave()\fR to indicate the name of the
file to create instead of modifying existing configuration file:
.PP
.Vb 1
\&  $cfg->write("app.cfg.bak");
.Ve
.PP
If you want the changes saved at all times, you can turn \f(CW\*(C`autosave\*(C'\fR mode on
by passing true value to \f(CW$cfg\fR\->\fIautosave()\fR. It will make sure before your program
is terminated, all the configuration values are written back to its file:
.PP
.Vb 2
\&  $cfg = new Config::Simple('aff.cfg');
\&  $cfg->autosave(1);
.Ve
.Sh "\s-1CREATING\s0 \s-1CONFIGURATION\s0 \s-1FILES\s0"
.IX Subsection "CREATING CONFIGURATION FILES"
Occasionally, your programs may want to create their own configuration files
on the fly, possibly from a user input. To create a configuration file from
scratch using Config::Simple, simply create an empty configuration file object
and define your syntax. You can do it by either passing \*(L"syntax\*(R" option to \fInew()\fR,
or by calling \fIsyntax()\fR method. Then play with \fIparam()\fR method as you normally would.
When you're done, call \fIwrite()\fR method with the name of the configuration file:
.PP
.Vb 3
\&  $cfg = new Config::Simple(syntax=>'ini');
\&  # or you could also do:
\&  # $cfg->autosave('ini')
.Ve
.PP
.Vb 5
\&  $cfg->param("mysql.dsn", "DBI:mysql:db;host=handalak.com");
\&  $cfg->param("mysql.user", "sherzodr");
\&  $cfg->param("mysql.pass", 'marley01');
\&  $cfg->param("site.title", 'sherzodR "The Geek"');
\&  $cfg->write("new.cfg");
.Ve
.PP
This creates a file \*(L"new.cfg\*(R" with the following content:
.PP
.Vb 2
\&  ; Config::Simple 4.43
\&  ; Sat Mar  8 00:32:49 2003
.Ve
.PP
.Vb 2
\&  [site]
\&  title=sherzodR "The Geek"
.Ve
.PP
.Vb 4
\&  [mysql]
\&  pass=marley01
\&  dsn=DBI:mysql:db;host=handalak.com
\&  user=sherzodr
.Ve
.PP
Neat, huh? Supported syntax keywords are \*(L"ini\*(R", \*(L"simple\*(R" or \*(L"http\*(R". Currently
there is no support for creating simplified ini\-files.
.Sh "\s-1MULTIPLE\s0 \s-1VALUES\s0"
.IX Subsection "MULTIPLE VALUES"
Ever wanted to define array of values in your single configuration variable? I have!
That's why Config::Simple supports this fancy feature as well. Simply separate your values
with a comma:
.PP
.Vb 1
\&  Files hp.cgi, template.html, styles.css
.Ve
.PP
Now \fIparam()\fR method returns an array of values:
.PP
.Vb 2
\&  @files = $cfg->param("Files");
\&  unlink $_ for @files;
.Ve
.PP
If you want a comma as part of a value, enclose the value(s) in double quotes:
.PP
.Vb 1
\&  CVSFiles "hp.cgi,v", "template.html,v", "styles.css,v"
.Ve
.PP
In case you want either of the values to hold literal quote ("), you can
escape it with a backlash:
.PP
.Vb 1
\&  SiteTitle "sherzod \e"The Geek\e""
.Ve
.Sh "\s-1TIE\s0 \s-1INTERFACE\s0"
.IX Subsection "TIE INTERFACE"
If \s-1OO\s0 style intimidates you, and \f(CW\*(C`import_from()\*(C'\fR is too simple for you,
Config::Simple also supports \fItie()\fR interface. This interface allows you to \fItie()\fR
an ordinary Perl hash to the configuration file. From that point on, you can use 
the variable as an ordinary Perl hash. 
.PP
.Vb 1
\&  tie %Config, "Config::Simple", 'app.cfg';
.Ve
.PP
.Vb 3
\&  # Using %Config as an ordinary hash
\&  print "Username is '$Config{User}'\en";
\&  $Config{User} = 'sherzodR';
.Ve
.PP
The difference between \f(CW\*(C`import_from($file, \e%Hash)\*(C'\fR is, all the changes you make
to the hash after \fItie()\fRing it, will also reflect in the configuration file object.
If \fIautosave()\fR was turned on, they will also be written back to file:
.PP
.Vb 2
\&  tie %Config, "Config::Simple", "app.cfg";
\&  tied(%Config)->autosave(1);
.Ve
.PP
To access the method provided in \s-1OO\s0 syntax, you need to get underlying Config::Simple
object. You can do so with \fItied()\fR function:
.PP
.Vb 1
\&  tied(%Config)->write();
.Ve
.PP
\&\s-1WARNING:\s0 tie interface is experimental and not well tested yet. Let me know if you 
encounter a problem.
.SH "MISCELLANEOUS"
.IX Header "MISCELLANEOUS"
.Sh "\s-1CASE\s0 \s-1SENSITIVITY\s0"
.IX Subsection "CASE SENSITIVITY"
By default, configuration file keys and values are case sensitive. Which means,
\&\f(CW$cfg\fR\->param(\*(L"User\*(R") and \f(CW$cfg\fR\->param(\*(L"user\*(R") are referring to two different values.
But it is possible to force Config::Simple to ignore cases all together by enabling
\&\f(CW\*(C`\-lc\*(C'\fR switch while loading the library:
.PP
.Vb 1
\&  use Config::Simple ('-lc');
.Ve
.PP
\&\s-1WARNING:\s0 If you call \fIwrite()\fR or \fIsave()\fR, while working on \f(CW\*(C`\-lc\*(C'\fR mode, all the case
information of the original file will be lost. So use it if you know what you're doing.
.Sh "\s-1USING\s0 \s-1QUOTES\s0"
.IX Subsection "USING QUOTES"
Some people suggest if values consist of none alpha-numeric strings, they should be
enclosed in double quotes. Well, says them! Although Config::Simple supports parsing
such configuration files already, it doesn't follow this rule while writing them. 
If you really need it to generate such compatible configuration files, \f(CW\*(C`\-strict\*(C'\fR
switch is what you need:
.PP
.Vb 1
\&  use Config::Simple '-strict';
.Ve
.PP
Now, when you write the configuration data back to files, if values hold any none alpha-numeric
strings, they will be quoted accordingly. All the double quotes that are part of the
value will be escaped with a backslash.
.Sh "\s-1EXCEPTION\s0 \s-1HANDLING\s0"
.IX Subsection "EXCEPTION HANDLING"
Config::Simple doesn't believe in dying that easily (unless you insult it using wrong syntax).
It leaves the decision to the programmer implementing the library. You can use its \fIerror()\fR \-
class method to access underlying error message. Methods that require you to check
for their return values are \fIread()\fR and \fIwrite()\fR. If you pass filename to \fInew()\fR, you will
need to check its return value as well. They return any true value indicating success,
undef otherwise:
.PP
.Vb 2
\&  # following new() always returns true:
\&  $cfg = new Config::Simple();
.Ve
.PP
.Vb 2
\&  # read() can fail:
\&  $cfg->read('app.cfg') or die $cfg->error();
.Ve
.PP
.Vb 2
\&  # following new() can fail:
\&  $cfg = new Config::Simple('app.cfg') or die Config::Simple->error();
.Ve
.PP
.Vb 2
\&  # import_from() calls read(), so it can fail:
\&  Config::Simple->import_from('app.cfg', \e%Config) or die Config::Simple->error();
.Ve
.PP
.Vb 2
\&  # write() may fail:
\&  $cfg->write() or die $cfg->error();
.Ve
.PP
.Vb 2
\&  # tie() may fail, since it calls new() with a filename
\&  tie %Config, "Config::Simple", 'app.cfg' or die Config::Simple->error();
.Ve
.SH "METHODS"
.IX Header "METHODS"
.IP "\fInew()\fR" 4
.IX Item "new()"
\&\- constructor. Optionally accepts several arguments. Returns Config::Simple object.
Supported arguments are \fBfilename\fR, \fBsyntax\fR, \fBautosave\fR. If there is a single
argument, will be treated as the name of the configuration file.
.IP "autosave([$bool])" 4
.IX Item "autosave([$bool])"
\&\- turns 'autosave' mode on if passed true argument. Returns current autosave mode
if used without arguments. In 'autosave' mode Config::Simple writes all the changes
back to its file without you having to call \fIwrite()\fR or \fIsave()\fR
.IP "\fIread()\fR" 4
.IX Item "read()"
\&\- accepts name  of the configuration file to parse. Before that, it tries to 
guess the syntax of the file by calling \fIguess_syntax()\fR method. Then calls either of
\&\fIparse_ini_file()\fR, \fIparse_cfg_file()\fR or \fIparse_http_file()\fR accordingly. If the name
of the file is provided to the constructor \- \fInew()\fR, there is no need to call \fIread()\fR.
.IP "param([$name], [$value])" 4
.IX Item "param([$name], [$value])"
\&\- used for accessing and updating configuration variables. If used with no arguments
returns all the available names from the configuration file.
.IP "delete($name)" 4
.IX Item "delete($name)"
\&\- deletes a variable from a configuration file. \f(CW$name\fR has the same meaning and syntax
as it does in param($name)
.IP "\fIclear()\fR" 4
.IX Item "clear()"
\&\- clears all the data from the object. Calling \fIsave()\fR or turning \fIautosave()\fR on results
in an empty configuration file as well.
.IP "\fIvars()\fR" 4
.IX Item "vars()"
\&\- depending on the context used, returns all the values available in the configuration
file either as a hash or a reference to a hash
.IP "import_names([$NS])" 4
.IX Item "import_names([$NS])"
\&\- imports all the names from the configuration file to the caller's name space. Optional
argument, if passed, will be treated as the name space variables to be imported into.
All the names will be uppercased. Non-alphanumeric strings in the values will be underscored
.ie n .IP "import_from($file, \e%hash | $NS)" 4
.el .IP "import_from($file, \e%hash | \f(CW$NS\fR)" 4
.IX Item "import_from($file, %hash | $NS)"
\&\- class method. If the second argument is a reference to an existing hash, it will
load all the configuration contents into that hash. If the second argument is a 
string, it will be treated as the name space variables should be imported into, just
like \fIimport_names()\fR does.
.IP "get_block($name)" 4
.IX Item "get_block($name)"
is mostly used for accessing blocks in ini-styled configuration files. 
Returns a hashref of all the key/value pairs of a given block. Also supported by \fIparam()\fR
method with the help of \*(L"\-block\*(R" option:
.Sp
.Vb 3
\&  $hash = $cfg->get_block('Project');
\&  # is the same as saying:
\&  $hash = $cfg->param(-block=>'Project');
.Ve
.ie n .IP "set_block($name, $values)" 4
.el .IP "set_block($name, \f(CW$values\fR)" 4
.IX Item "set_block($name, $values)"
used in assigning contents to a block in ini-styled configuration files. \f(CW$name\fR should
be the name of a [block], and \f(CW$values\fR is assumed to be a hashref mapping key/value pairs.
Also supported by \fIparam()\fR method with the help of \*(L"\-block\*(R" and \*(L"\-value\*(R" (or \*(L"\-values\*(R") options:
.Sp
.Vb 3
\&  $cfg->set_block('Project', {Count=>3, 'Multiple Column' => 20});
\&  # is the same as:
\&  $cfg->param(-block=>'Project', -value=>{Count=>3, 'Multiple Column' => 20});
.Ve
.Sp
Warning: all the contents of a block, if previously existed will be wiped out.
If you want to set specific key/value pairs, use explicit method:
.Sp
.Vb 1
\&  $cfg->param('Project.Count', 3);
.Ve
.IP "\fIas_string()\fR" 4
.IX Item "as_string()"
\&\- returns the configuration file as a chunk of text. It is the same text used by
\&\fIwrite()\fR and \fIsave()\fR to store the new configuration file back to file.
.IP "\fIwrite()\fR" 4
.IX Item "write()"
\&\- writes the configuration file into disk. Argument, if passed, will be treated
as the name of the file configuration variables should be saved in.
.IP "\fIsave()\fR" 4
.IX Item "save()"
\&\- same as \fIwrite()\fR.
.IP "\fIdump()\fR" 4
.IX Item "dump()"
\&\- for debugging only. Dumps the whole Config::Simple object using Data::Dumper.
Argument, if passed, will be treated as the name of the file object should be dumped in.
The second argument specifies amount of indentation as documented in Data::Dumper
manual. Default indent size is 2.
.IP "\fIerror()\fR" 4
.IX Item "error()"
\&\- returns the last error message from read/write or import_* operations.
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
Support for lines with continuation character, '\e'. Currently its support
is restricted and quite possibly buggy.
.IP "\(bu" 4
Retaining comments while writing the configuration files back and/or methods for
manipulating comments. Everyone loves comments!
.IP "\(bu" 4
Retain the order of the blocks and other variables in the configuration files.
.SH "BUGS"
.IX Header "BUGS"
Submit bugs and possibly patches to Sherzod B. Ruzmetov <sherzodr@cpan.org>.
.SH "CREDITS"
.IX Header "CREDITS"
.IP "Michael Caldwell (mjc@mjcnet.com)" 4
.IX Item "Michael Caldwell (mjc@mjcnet.com)"
whitespace support, \f(CW\*(C`\-lc\*(C'\fR switch and for various bug fixes
.IP "Scott Weinstein (Scott.Weinstein@lazard.com)" 4
.IX Item "Scott Weinstein (Scott.Weinstein@lazard.com)"
bug fix in \s-1TIEHASH\s0
.IP "Ruslan U. Zakirov <cubic@wr.miee.ru>" 4
.IX Item "Ruslan U. Zakirov <cubic@wr.miee.ru>"
default name space suggestion and patch
.IP "Hirosi Taguti" 4
.IX Item "Hirosi Taguti"
\&\fIimport_names()\fR and \fIimport_from()\fR idea.
.IP "Vitaly Kushneriuk" 4
.IX Item "Vitaly Kushneriuk"
for bug fixes and suggestions
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 1
\&  Copyright (C) 2002-2003 Sherzod B. Ruzmetov.
.Ve
.PP
.Vb 2
\&  This software is free library. You can modify and/or distribute it
\&  under the same terms as Perl itself
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\&  Sherzod B. Ruzmetov E<lt>sherzodr@cpan.orgE<gt>
\&  URI: http://author.handalak.com
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Config::General, Config::Simple, Config::Tiny
